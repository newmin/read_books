# DAY-1 (2025-01-04)

## 오늘 읽은 범위
Episode 1 ~ Episode 5

## 책에서 기억하고 싶은 내용
- 좋은 개발자란 암기력이 아닌 개발 과정을 잘 이해하는 것.
  - 무엇이 필요한지, 어떻게 검색해야 문제를 해결 할 수 있는지
- 새언어를 빠르게 습득하는 방법
  - "공식문서 살펴보기" -> 언어의 철학, 올바른 사용 예시 등 숙지
  - 새언어로 완전히 새로운 프로젝트를 할 경우 나의 과제만 많아지고 그만큼 습득이 어려움 -> 기존에 만들었던 것을 새로운 언어로 다시 만드는 것
- 새 언어를 공부하는게 중요한 이유
  - 언어마다의 철학을 이해 -> 다른 언어로의 로직작성에도 적용해보면서 나의 생각 확장

* 개발자 잡학 지식
  - C언어는 당시 유명했던 B언어를 따라했다.
  - C++은 +1을 의미하는 ++이며 더 나은 언어라는 의미로 지었다.
    - [절차지향]에서 [절차지향, 객체지향]으로의 변화 -> 철학과 용도가 다를 뿐 결국은 둘 다 사용 됨
  - C#의 #은 ++이 위아래로 붙어있는 모양이다.
    - 음악에서 #은 반올림이란 뜻이다
    - 실상은 window에서 만든 java언어이다.

## 오늘 읽은 소감
- AI가 발달함에 따라 로직을 짜는 행위의 의미는 점점 더 무색해질 것 같다.
- 해당 프로세스를 어떻게 구성하고, 어떤 로직이 필요할 것인지, 또한 이를 위해 어떤 세팅들이 더 필요할지 전반적인 이해능력이 더욱 필요해질 듯 싶다.
- 공식문서는 제품 사용설명서와 같은 듯 하다. 영어라고 필요한 부분만 읽으려하지말고 시간내서 조금씩 다 읽어보도록 노력하자
- FLUTTER를 학습하면서 새로운 프로젝트를 실행했을 떄 많은 고됨을 느꼈었다. 이후에 새로운 언어 학습에서는 새로운 프로젝트를 만들기보다 기존 프로젝트를 다시 만들어보자


---
---
# DAY-2 (2025-01-05)

## 오늘 읽은 범위
Episode 6 ~ Episode 10

## 책에서 기억하고 싶은 내용
- 인터프리트 언어(Interpreted language) : 실시간 통역; 파이썬
- 컴파일 언어(Compiled language) : 빌드할 때 번역; 자바
- JavaScript로도 모바일, 게임, 머신러닝 등 다양한 것을 개발할 수 있다. 실제 사례들도 많다.
  
* 피해야할 것
- 공부만 하고 실제로 무언가 만들어보지 않는 것
- 프로그래밍할 준비가 더 필요하다고 미루는 것

* 개발자 잡학 지식
  - 세상엔 참 쓸데없는 언어가 많다...
    - Brainfuck : 뇌를 아주 화나게 만드는 언어이다. +++++[>>+++>++++++<..>++ 뭐 이런 느낌의 언어다
    - 형 : 너무 야하다. 히어엉...혀어엉...아.... 이런다....진짜루...

## 오늘 읽은 소감
- 자바 vs 코틀린, 인터프리트vs컴파일, 파이썬이나 자바스크립트 등 언어에 대한 지식이 많은 에피소드들이었다.
앞서 다른 언어를 학습하며 해당 언어의 철학이나 구조를 이해하고 확산하며 내 실력이 상승된다고 하였는데, 이렇게 비슷하면서도 다른 부분에 대해서 알아보면 되겠구나 이해하게 되었다.

- 완벽한 소극주의에 휩쓸리지 않도록 학습에는 실습을 포함시키는 노력을 해야겠다.
  

## 궁금하거나 이해되지 않는 부분
- 책에서는 인터프리트언어가 97번째 줄까지 잘 작동하다가 98번째 줄에서 오류가 날 경우 앞의 97줄까지 실행한 시간을 모두 버린다고 하는데 이해가 잘 되지 않는다. 컴파일 또한 순차적으로 실행되다가 오류가 발견되면 롤백되는 느낌 아닌가? 어떻게 다르다는건지 좀 더 알아볼 필요가 있겠다.

![image](https://github.com/user-attachments/assets/7d44eb06-93ce-4b95-af5e-98a7513584c3)


---
---
# DAY-3 (2025-01-07)

## 오늘 읽은 범위
Episode 11 ~ Episode 15

## 책에서 기억하고 싶은 내용
- API : 프로그램끼리 소통할 때 쓰는 일종의 규칙을 코드화한 것
- API 특징 : 사용하는 사람은 결과만을 반환받고 그 과정은 알 수 없음

- 도메인은 전화번호부와 비슷하다. 전화번호를 외우지 않고 엄빠로 저장하듯, IP주소 202.131.30.11을 외우기 힘드므로 naver.com라는 도메인을 사용하는 것.
- 레지스트리 : naver, google 등의 뒤에 붙는 .com, co.kr, tv, org 등등
- 도메인이 너무 많기 때문에 도메인을 나누어서 관리하고 해당 도메인이 어디에서 관리되고 있는지 확인하기 위해 붙은 것이 레지스트리이다.
- 레지스트리는 누구나 만들 수 있다! 아이캔(ICANN)에 신청만 하면 된다! 물론 많은 돈과 그것을 관리할 능력이 있다는 것을 증명만 한다면.

- 플래시 : 애니메이션을 브라우저에 띄울 수 있게 해주는 프로그램
  - 한때는 윕에서는 없어선 안되는 필수 프로그램이었으나
  - 오픈소스가 아닌 점(어도비에서 인수) 때문에 IOS에서 배제 -> 플래시가 없어도 되는 웹기술이 HTML5, CSS3에 도입되고 점차 플래시는 사장되다 2020년 종료됨

* 공부할 때 주의할 것
  - 공부했는지 체크하기 위해서만 공부하지 말것
    

## 오늘 읽은 소감
- 체크리스트를 채우는 것은 효과적인 학습 방법보다 효과적인 습관만들기 방법에 가까운 것 같다.
- 여러 챌린지를 통해 학습의 습관은 형성되었으나, 공부하기 싫은 날 챌린지를 위해서만 학습한 날들이 있었다. 이를 통해 매일 밤 공부습관이 생긴 것은 GOOD! 이제는 기왕 공부시간을 가지는거 가능한 나의 지식으로 만들 수 있도록 노력하자
- 하나의 기업에 의존해야 하는 기술을 리스크를 지닐 수 밖에 없다 -> 최근 오라클 소송건으로도 많은 관심이 쏠렸고 결국 구글이 승소하긴 했으나 위기의식을 느낄 수 있었다. 최근 플러터를 학습하면서도 구글에서 이 엔진을 끝까지 가지고 갈지 걱정하면서 학습했던 것이 상기되었다.

## 내가 개발을 하는 이유
![image](https://github.com/user-attachments/assets/023fc335-f458-44e9-acac-30fdc88ea7ea)


---
---
# DAY-4 (2025-01-08)

## 오늘 읽은 범위
Episode 16 ~ Episode 21

## 책에서 기억하고 싶은 내용
- 전세계 브라우저 시장의 95%를 점유했던 익스플로러는 취약점 보안에 게을러 타 브라우저들의 성장 여지를 줘버렸다.
- HTTP : HyperText Transfer Protocol
  - 우리와 서버는 항상 연결되어 있는 것은 아니다(stateless)
  - 이 때문에 연속성을 가지기 위해 쿠키의 도입
- 쿠키의 특징
  - 쿠키는 도메인 하나에만 한정 : 도메인A에서 만든 쿠키를 도메인B로 넘겨서는 안 된다.
  - 쿠키는 자동으로 전달 : 서버에 전달하기 위해 알림이나 동의를 구하지 않는다( 일부 첫 방문시 물어보는 곳도 있음 )
- 풀스택 = 프론트 + 백 + 데브옵스( DevOps : Develop + Operations )
  - 프론트,백의 개발로 끝이 아닌, 서버를 고르고 설정하고 SW를 설치하고, DB도 설정하고, 보안도 챙기고 등등 모든 것을 담당. 거의 1인 스타트업에 준함
  - 단, 모든 것을 할 수 있는 것과 모든 것을 하는 것은 다름. 나의 R&R이 어디까지인지 분명히 체크해야한다.

  * 익스텐션 추천
    - JSON Viewer : 개발자 도구의 일렬로 된 JSON을 예쁘게 보여줌
    - Color Zilla : 브라우저 내 색상 스포이드 익스텐션 추천 해주었으나, 기존에 사용하던 ""PowerToys""가 조금 더 유용해 보임
 
## 오늘 읽은 소감
- 왕좌는 영원하지 않다. 하지만 노력 여하에 따라 기간의 길고 짧음은 충분히 바꿀 수 있을 것이다. 자만하지 말고 게을러지지 말자
- 풀스택 개발자가 아니더라도 R&R을 명확히 아는 것은 중요한 것 같다. 다른 사람의 역할 부재를 내가 할 수 있는 일이기에 일부나마 처리하려다보니 자연스레 나의 책임으로 넘어오더라.

## 궁금하거나 이해되지 않는 부분
- 일반적으로 쿠키는 자동으로 서버에 전달되나, 일부 쿠키 동의여부를 묻는 곳에서는 필수/선택의 나뉘는 곳들이 많았다. 자동전달 되는 곳은 어떤 정보들만 전달되고, 쿠키로 어느 정도의 선까지 뽑아 낼 수 있을지 그 디테일이 궁금해졌다.

---
---
# DAY-5 (2025-01-09)

## 오늘 읽은 범위
Episode 22 : 자료구조와 알고리즘은 필수라고?
Episode 23 : 배열이 뭐죠?
Episode 24 : 알고리즘의 속도는 어떻게 표현할까?
Episode 25 : 검색 알고리즘이 뭐죠?


## 책에서 기억하고 싶은 내용
- 알고리즘 : 컴퓨터에게 내리는 지시사항을 나열한 것
  - Ex.) 출근길 : 어떤 루트로 이동하고 어떤 교통수단을 활용하는 지의 따라 비용과 시간이 달라진다. 최단루트를 찾아내는데 사용되는 것이 패스파인더 알고리즘
- 자료구조 : 데이터의 효율적인 보관 및 검색을 위한 저장 방식
- Big O : 시간복잡도를 나타내는 말이며, 실제로 걸린 시간이 아닌 실행단계에 영향을 주는 요소로 정해짐
  - O(N), O(N^2) 등으로 나타냄
- 검색 알고리즘 -> 검색을 위해 로직의 나열
  - 선형검색 : 일반적으로 생각되는 처음부터 끝까지 선형 방향으로 검색타겟을 찾아보는 것
  - 이진검색 : 업다운 게임의 공략 방식 -> 중앙부터 확인하고, 다음 중앙, 다음 중앙의 방식으로 검색수를 획기적으로 줄일 수 있음. 단, 순서대로 정렬되는 것이 선제조건

 
## 오늘 읽은 소감
처음 개발을 배울 때 알고리즘을 잘 짜는 개발자가 좋은 개발자라는 말을 주워듣곤 열심히 알고리즘 문제들을 풀었다.
하지만 막상 취업을 해서 여러 프로젝트를 뛰는동안 알고리즘을 유용하게 사용한 경험이 없었다.
그렇게 차차 알고리즘과의 거리가 멀어지며 알고리즘이 왜 중요한건지 의문을 품게 되었다.
이 책에서는 처음엔 로직이 잘 작동되도록 하는게 먼저이고 그 후, 관리하기 편하고 효율적이며 속도도 빠른 코드를 고민하게 된다고 한다.
요즘 비슷한 화면을 만들면서도 이전에 했던 방식보다 더 효율적인 방법을 무엇일지, 관리하기 편한 방법은 무엇일지 고민하게 된다.
'나에게 지금이 딱 알고리즘 공부하기 좋은 시기이구나' 느낄 수 있었다.
현재 학습하고 있는 것들이 끝나면 알고리즘 공부 또한 다음 범위에 추가해봐야겠다.


## 궁금하거나 이해되지 않는 부분
O(N^2)이라고 무조건 나쁜 것인가?
배열 안의 배열을 각 조회하기 위해 이중반복문이 쓰이는 때가 있는데, 이는 반드시 고쳐야하는 방법일까?
자료구조를 다른 방식으로 수정하도록 할지, 적당히 O(N^2)를 써도 될지 궁금해졌다.
의사결정을 위해서도 이에 대해 학습할 필요가 있겠다.



## 다른 사람들의 TIL 감상

https://nomadcoders.co/community/thread/10619

지금 필요하고 인상 깊었던 부분의 내용을 작성할 경우
나중에 다시 읽을 때와 지금의 나는 다른 부분에서 포인트를 잡을 수 있다.
해당 TIL는 모든 에피소드별 포인트를 잡음으로서 나중에 다시 볼때도 빠지는 것 없이 챙겨볼 수 있을 것이다.

---
https://nomadcoders.co/community/thread/10622

굵기, 색상, OL 등으로 내용을 구분함으로서 글을 체계적으로 읽을 수 있다.
디테일 노력이 돋보였다.

---
https://velog.io/@errorose/%EB%85%B8%EA%B0%9C%EB%B6%81-ep.16-21

간단한 줄글의 내용임에도 읽기 좋은 바이브이다.



---
---
# DAY-6 (2025-01-11)

## 오늘 읽은 범위
Episode 26 : 정렬 알고리즘이 뭐죠?
Episode 27 : 스택, 큐가 뭐죠?
Episode 28 : 해시 테이블이 뭐죠?
Episode 29 : 개발자 필수 소양, 클린 코드!


## 책에서 기억하고 싶은 내용
### Episode 26 : 정렬 알고리즘이 뭐죠?
- 버블 정렬 : 좌측에서부터 우측으로 하나씩만 서로 비교하여 작은 것은 왼쪽, 큰 것은 오른쪽으로 교체함. 이럴 경우 가장 큰 것은 가장 오른쪽으로 이동됨. 이것이 한"사이클". 마찬가지로 가장 왼쪽에서 가장오른쪽-1(이미 가장 오른쪽이 가장 큰수임을 앎) 사이클을 돌리면 그 다음 큰숫자가 그 다음 오른쪽으로 이동. 이를 반복.
  - 시간복잡도 : O(N^2)
- 선택 정렬 : 가장 작은/큰 데이터의 위치를 기억하고 교환
  - 시간복잡도 : O(N^2) -> 버블정렬과 동일한 시간복잡도를 가졌지만, 자리를 바꾸는 연산이 사이클 당 1번뿐이라는 점에서 훨씬 효율적임을 알 수 있음
- 삽입 정렬 : 순서대로 n번째의 수를 0~n까지 중 위치를 파악해서 삽입.
  - 시간복잡도 : O(N^2) -> 버블정렬,선택정렬과 동일한 시간복잡도를 가졌지만,보다 빠름

### Episode 27 : 스택, 큐가 뭐죠?
스택 : 후입선출 ; 스택이 "쌓이다"라고 표현 -> 쌓여있기 때문에 가장 아래의 것은 건들기 어려울 것이고 가장 위의 것을 사용하게 된다.
큐 : 선입선출 ; 당구의 한 "큐"를 떠올려보자. 공이 여러개 나열되어 있을 때 다른 공으로 그 나열의 맨뒤를 치게 되면 가장 앞에 놓여있던 공이 튀어나갈 것이다.

### Episode 28 : 해시 테이블이 뭐죠?
- 오브젝트 , JSON 느낌. 시간복잡도 O(1). 왜냐면, key 하나만 찾으니까!
- 해시 또한 배열이다. 해시에서 사용되는 키를 실제 배열에서 사용될 인덱스로 매핑시켜주는 "해시함수"가 있다.
- 해시 함수의 리턴이 인덱스가 겹치는 경우를 "해시 충돌"이라고 표현한다.
- 이 경우, 배열 안의 배열을 둠으로써 해결한다.

### Episode 29 : 개발자 필수 소양, 클린 코드!
- 변수,함수의 이름을 의미있게 지어라.
- 동사를 사용하면 파악이 용이
- 매개변수를 너무 많이 사용하지마라. 필요하다면 오브젝트로 묶어서 보내는 빙법 고려
- boolean값을 인자로 보내지마라. 함수는 하나의 역할만 잘하는게 좋음. 저걸로 if로 구분해서 두가지 일로 나뉘는 것을 지양
- 축약어 지양. 타인이 보았을 때 이해하기 어려울 수 있음. 첫번째 "변수,함수의 이름을 의미있게 지어라."와 상동
 
## 오늘 읽은 소감
- 복잡도와 속도는 다른 것 같다. 우리가 문제를 풀 때도 문제의 난이도가 있지만 난이도가 같다고 해서 동일한 속도를 문제를 풀 수 있는건 아닌 느낌?
- 스택과 큐를 구별하는 나만의 방법. 잘 짠거 같아서 뿌듯
- 해시테이블이 사실은 배열? Amazing
- 특정상황에서는 항상 boolean값을 인자로 보내왔던 나로서는 충격적이다. 예를 들어 임시저장과 확정버튼에서 동일한 저장함수를 사용하되, isConfirm값을 통해 확정에서만의 로직을 구분지었는데... 추후 작업에는 꼭 반영해야겠다.

